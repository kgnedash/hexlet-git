Commands:
$ cd - change directory
$ pwd - present working directory — текущий рабочий каталог или print working directory — вывести рабочий каталоu
$ ls - выводит список файлов текущей директории
$ touch - create file if it wasn`t exist. Основная задача утилиты — поменять время последнего доступа к файлу.
$ rm - delete file.
$ mv - rename file. В *nix-системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению.
$ cp - copying file or directory. первый аргумент — имя источника (откуда), второй — имя приёмника (куда). Для копирования директории нужно добавить флаг -r (recursive).
$ mkdir - create directory. # $ mkdir -p one/two/three флаг -p создаёт директории рекурсивно.

$ man - shows description of argument command
$ cat - reading the file
$ head/tail - чтение 10 первых/последних строк файла, через n можно указать количество строк ($ head -n 2 .bashrc) ($ sudo tail -f syslog не просто выводит последние строчки файла, но ждёт появления новых, Для остановки её выполнения нажмите Ctrl + C)
(# Вероятно у вас не хватит прав смотреть файл syslog, чтобы получить к нему доступ,
# наберите sudo перед командой tail как показано ниже, в следующих уроках этот вопрос рассматривается подробнее
# Есть вероятность того, что sudo попросить вас ввести пароль. Сделайте это и нажмите Enter. При наборе пароля
# курсор не будет двигаться, это сделано для безопасности. $ sudo tail -f syslog)
$ sudo less syslog - Особая категория программ для просмотра содержимого файла — пейджеры. Пейджер похож на текстовый редактор, но открытый только в режиме чтения.
$ grep - (global regular expression print), выполняет поиск по файлу или файлам определённого текста. Количество выводимых соседних строк регулируется опциями -B, -A и -C. Первая определяет количество отображаемых строк до искомой (-B, --before-context), вторая — после (-A, --after-context), а третья — до и после одновременно (-C, --context).
$ stat - (file system status)информация о файле

chmod u=wrx,g=wrx,o=wrx filename //изменение прав доступа к файлу

$ vim .bashrc - Ключевое отличие (а их много!) вима от остальных редакторов — в наличии режимов. В обычных редакторах, после того как открылся файл, можно сразу приступать к редактированию. 
Вим, после открытия, работает в режиме команд (COMMAND): нажатие на любую клавишу воспринимается как сигнал к какому-то действию. Если вы не знаете команд, то лучше ничего не трогать, иначе на экране начнётся хаос. 
Обычное редактирование текста выполняется в режиме ввода (INSERT) и попасть в него можно нажав клавишу i. Для выхода в режим команд достаточно нажать Esc (или комбинацию Ctrl + [).
Говорят, что самое сложное в виме — это выйти, поэтому подготовимся заранее. Убедитесь, что вы находитесь в командном режиме, на всякий случай нажмите Esc (или комбинацию Ctrl + [). 
Затем наберите :, эта команда переведёт вас в режим командной строки (ещё один режим), затем введите q! и нажмите Enter. Так вы выйдите из вима без сохранения изменений. 
Если набрать :wq, то перед выходом сохранятся все изменения. Если вы хотите просто сохраниться без выхода, то наберите :w.
В Vim есть четыре основных режима работы:
-Командный режим (обычный режим) — это режим по умолчанию. Перемещение по файлу, быстрое (при помощи команд, комбинаций клавиш) редактирование, удаление, поиск текста.
-Режим вставки (режим ввод) — ввод текста с клавиатуры. То, как вы привыкли это делать в обычных редакторах.
-Визуальный режим — выделение произвольных участков текста.
-Режим командной строки — собственная командная строка для редактора текста, из которой можно выполнять великое множество разнообразных команд.

$ ls -la > output операция, которую мы сделали называется перенаправление потоков. Символ > означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. 
> всегда перезаписывает файл. Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.
#$ grep alias .bash_profile > result
#$ cat result
#alias fixssh=eval 
Если нужно не перезаписывать, а добавлять, то используйте >>.
Для экспериментов с выводом удобно использовать встроенную в шелл команду echo. Она принимает на вход строчку и выдаёт её в STDOUT, который уже можно перенаправлять.
# > перетирает файл
$ echo hello > result
$ cat result
hello
$ echo hello > result
$ cat result
hello
# >> добавляет содержимое в конец файла
$ echo hello >> result
$ cat result
hello
hello
$
Кроме стандартного вывода, с каждым процессом ассоциируются два дополнительных потока: один STDIN (стандартный ввод) и STDERR (вывод ошибок). STDIN работает в обратную сторону: через него программа может получать данные на вход. 
В *nix-системах встроена утилита wc (word count — "количество слов"), которая умеет считать количество слов, строк или символов в файле. Когда мы говорим о файле, то в *nix это почти всегда означает, что данные можно передать и в стандартный поток ввода.
# Флаг l (l а не 1) говорит о том, что надо считать количество строк
$ wc -l < result
2
Выглядит довольно логично — стрелка меняет своё направление в другую сторону и содержимое файла отправляется в STDIN запускаемой программы wc. Теперь сделаем финт и объединим перенаправление ввода и вывода.
$ wc -l < result > output
$ cat output
$ 2

GIT COMMANDS
git status //repository status
git add <file> //подготовка к коммиту(добавление в индекс)
git commit -m // отправка подготовленных изменений в репозиторий -m описание комита
git push //отправка коммитов в репозиторий гита
git pull --rebase // скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий
git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git // клонирование репозитория в свою рабочую директорию
git restore <file> // восстановление удаленного файла в локальной директории
git diff // показывает изменения модифицированных файлов, --staged покажет изменения файлов добавленные в индекс
git log // показывает список всех выполненных коммитов, отсортированных по дате добавления (сверху самые последние), есть полезный флаг -p, который сразу выводит диф для каждого коммита
git show <hash> //посмотреть все изменения, сделанные в рамках одного коммита
git blame <file> //выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите
git grep <letters> //ищет совпадение с указанной строкой во всех файлах проекта # Флаг i позволяет искать без учета регистра
git clean -fd //Откат незакоммиченных изменений в локальном репозитории

